{"pages":[],"posts":[{"title":"23种设计模式之（一）单例模式（Singleton）","text":"本文主要介绍23种设计模式之单例模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 单例模式（Singleton）概念单例模式是一种对象创建型模式，使用单例模式，可以保证为一个类只生成唯一的实例对象。也就是说，在整个程序空间中，该类只存在一个实例对象。GoF对单例模式的定义是：保证一个类、只有一个实例存在，同时提供能对该实例加以访问的全局访问方法。 应用场景一个无状态的类使用单例模式节省内存资源。为了性能的考虑，需要节省对象的创建时间，全局变量，共享资源，如全局连接池，客户端全局配置项，客户端账号信息等。 注意事项C++多线程下懒汉式使用线程锁 代码示例C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include \"stdafx.h\"#include &lt;Windows.h&gt;#include &lt;iostream&gt;/************************************************************************//* 设计模式专题/*/* 单例模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180912/************************************************************************/class Singelton{private: Singelton() { m_SingeltoInstance = NULL; printf(\"构造函数Singelton ... do\\n\"); }public: static Singelton *getInstance() { return m_SingeltoInstance; } static void Singelton::FreeInstance() { if (m_SingeltoInstance != NULL) { delete m_SingeltoInstance; m_SingeltoInstance = NULL; } }private: static Singelton *m_SingeltoInstance;};Singelton *Singelton::m_SingeltoInstance = new Singelton; //不管你创建不创建实例，均把实例new出来//懒汉式考虑多线程//临界区CRITICAL_SECTION g_cs;//全局关键代码段对象class SingletonB{private: SingletonB() { printf(\"Singleton begin\\n\"); } SingletonB(const SingletonB &amp;); SingletonB&amp; operator = (const SingletonB &amp;);public: static SingletonB *getInstance() { if(m_SingeltoInstance == NULL) //double check { EnterCriticalSection(&amp;g_cs); //只有当pInstance等于null时，才开始使用加锁机制 二次检查 if(m_SingeltoInstance == NULL) { m_SingeltoInstance = new SingletonB(); } LeaveCriticalSection(&amp;g_cs); } return m_SingeltoInstance; } static void SingletonB::FreeInstance() { if (m_SingeltoInstance != NULL) { delete m_SingeltoInstance; m_SingeltoInstance = NULL; } } static SingletonB *m_SingeltoInstance;};SingletonB *SingletonB::m_SingeltoInstance =NULL; void main1(){ Singelton *pSingelto1 = Singelton::getInstance(); //只有在使用的时候，才去创建对象。 Singelton *pSingelto2 = Singelton::getInstance(); if (pSingelto1 != pSingelto2) { printf(\"不是同一个对象\\n\"); } else { printf(\"是同一个对象\\n\"); } Singelton::FreeInstance(); InitializeCriticalSection(&amp;g_cs); SingletonB *pSingelto3 = SingletonB::getInstance(); //只有在使用的时候，才去创建对象。 SingletonB *pSingelto4 = SingletonB::getInstance(); if (pSingelto3 != pSingelto4) { printf(\"不是同一个对象\\n\"); } else { printf(\"是同一个对象\\n\"); } SingletonB::FreeInstance(); DeleteCriticalSection(&amp;g_cs);//删除关键代码段对象} python代码示例123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 单例模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180912##################################################################import threadingclass Singleton(object): _instance_lock = threading.Lock() def __init__(self): pass def __new__(cls, *args, **kwargs): if not hasattr(Singleton, \"_instance\"): with Singleton._instance_lock: if not hasattr(Singleton, \"_instance\"): Singleton._instance = object.__new__(cls) return Singleton._instanceif __name__ == \"__main__\": singleton__instance1 = Singleton() singleton__instance2 = Singleton() print(singleton__instance1, singleton__instance2) def task(args): singleton__instance = Singleton() print(singleton__instance) for i in range(10): t = threading.Thread(target=task, args=[i, ]) t.start() 源码链接设计模式（一）单例模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（一）单例模式（python_c++实现)/"},{"title":"23种设计模式之（七）装饰模式（Decorator）","text":"本文主要介绍23种设计模式之装饰模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 装饰模式（Decorator）概念装饰（ Decorator ）模式又叫做包装模式，通过一种对客户端透明的方式来扩展对象的功能，是继承关系的一个替换方案，装饰模式就是把要添加的附加功能分别放在单独的类中，并让这个类包含它要装饰的对象，当需要执行时，客户端就可以有选择地、按顺序地使用装饰功能包装对象。 GoF对装饰模式的定义是：动态地给一个对象添加一些额外的职责，就扩展功能而言，Decorator模式比生成子类方式更为灵活。 ##应用场景 （1）当系统需要扩展一个类的功能，或者客户端需要动态的给一个对象添加功能，并且使用继承会很复杂时候。 （2）当要改变已有函数的功能，这个函数又在多处被使用不方便改动原函数和改动调用方代码，这种场景python的装饰器工作得很好。 代码示例C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/************************************************************************//* 设计模式专题/*/* 装饰模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180915/************************************************************************/#include &lt;iostream&gt;using namespace std;class Car{public: virtual void show() = 0;};class RunCar : public Car {public: virtual void show() { printf(\"i can run\\n\"); }};class SwimCarDecorator : public Car{public: SwimCarDecorator(Car *car) { m_car = car; } void swim() { printf(\"i can swim\\n\"); } virtual void show() { m_car-&gt;show(); swim(); }private: Car *m_car;};class FlyCarDecorator : public Car{public: FlyCarDecorator(Car *car) { m_car = car; } void fly() { printf(\"i can fly\\n\"); } virtual void show() { m_car-&gt;show(); fly(); }private: Car *m_car;};void main(){ Car * mycar = NULL; printf(\"-----1.-------\\n\"); mycar = new RunCar; mycar-&gt;show(); printf(\"-----2.fly --------\\n\"); FlyCarDecorator *flycar = new FlyCarDecorator(mycar); flycar-&gt;show(); printf(\"----3.swim---------\\n\"); SwimCarDecorator *swimcar = new SwimCarDecorator(flycar); swimcar-&gt;show(); delete swimcar; delete flycar; delete mycar;} python代码示例1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 装饰模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180915################################################################### python 语言本身特性支持装饰器def fly(func): def inner(*args, **kwargs): print(\"i can fly\") return func(*args, **kwargs) return innerdef swim(func): def inner(*args, **kwargs): print(\"i can swim\") return func(*args, **kwargs) return inner@fly@swimdef run_car(): print (\"i can run \")if __name__ == \"__main__\": run_car() 源码链接设计模式（七）装饰模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（七）装饰模式（python_c++实现）/"},{"title":"23种设计模式之（九）组合模式（Composite）","text":"本文主要介绍23种设计模式之组合模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 组合模式（Composite）概念组合模式，是构造型的设计模式之一。通过递归手段依据树形结构来组合对象，用来表示部分以及整体层次，并可以通过一个对象来访问整个对象树，把一组相似的对象当作一个单一的对象 这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。 GoF对组合模式的定义是：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性。 ##应用场景 （1）客户程序需要像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 （2）用户需要忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象（如树形菜单，文件、文件夹的管理）。 代码示例C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/************************************************************************//* 设计模式专题/*/* 组合模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180916/************************************************************************/#include &lt;iostream&gt;#include \"string\"#include \"list\"class IFile{public: virtual void display() = 0; virtual int add(IFile *ifile) = 0; virtual int remove(IFile *ifile) = 0; virtual std::list&lt;IFile *&gt;* getChild() = 0;};//文件结点 class File : public IFile{public: File(std::string name) { m_name = name; } virtual void display() { printf(\"%s\\n\",m_name.c_str()); } virtual int add(IFile *ifile) { return -1; } virtual int remove(IFile *ifile) { return -1; } virtual std::list&lt;IFile *&gt;* getChild() { return NULL; }private: std::string m_name;};//目录 结点 class Dir : public IFile{public: Dir(std::string name) { m_name = name; m_list = new std::list&lt;IFile *&gt;; m_list-&gt;clear(); } virtual void display() { printf(\"%s\\n\",m_name.c_str()); } virtual int add(IFile *ifile) { m_list-&gt;push_back(ifile); return 0; } virtual int remove(IFile *ifile) { m_list-&gt;remove(ifile); return 0; } virtual std::list&lt;IFile *&gt;* getChild() { return m_list; }private: std::string m_name; std::list&lt;IFile *&gt; *m_list;};// 递归的显示树void showTree(IFile *root, int level){ int i = 0; if (root == NULL) { return ; } for (i=0; i&lt;level; i++) { printf(\"\\t\"); } //1 显示根 结点 root-&gt;display(); //2 若根结点 有孩子 //判读孩子是文件,显示名字 ) //判断孩子是目录,showTree(子目录) std::list&lt;IFile *&gt; *mylist = root-&gt;getChild(); if (mylist != NULL) //说明是一个目录 { for (std::list&lt;IFile *&gt;::iterator it=mylist-&gt;begin(); it!=mylist-&gt;end(); it++) { if ( (*it)-&gt;getChild() == NULL ) { for (i=0; i&lt;=level; i++) //注意 &lt;= { printf(\"\\t\"); } (*it)-&gt;display(); } else { showTree(*it, level+1); } } }}void main(){ Dir *root = new Dir(\"C\"); //root-&gt;display(); Dir *dir1 = new Dir(\"111dir\"); File *aaafile = new File(\"aaa.txt\"); //获取root结点下的 孩子集合 std::list&lt;IFile *&gt; *mylist = root-&gt;getChild(); root-&gt;add(dir1); root-&gt;add(aaafile); for ( std::list&lt;IFile *&gt;::iterator it=mylist-&gt;begin(); it!=mylist-&gt;end(); it++ ) { (*it)-&gt;display(); } Dir *dir222 = new Dir(\"222dir\"); File *bbbfile = new File(\"bbb.txt\"); dir1-&gt;add(dir222); dir1-&gt;add(bbbfile); printf(\"--------showTree---------\\n\"); showTree(root, 0);} python代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 组合模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180916##################################################################class IFile(object): def display(self): pass def add(self, ifile): pass def remove(self, ifile): pass def get_child(self): pass# 文件结点class File(IFile): def __init__(self, name): self.m_name = name def display(self): print(self.m_name) def add(self, ifile): return -1 def remove(self, ifile): return -1 def get_child(self): return None# 目录结点class Dir(IFile): def __init__(self, name): self.m_name = name self.m_list = [] m_name = name def display(self): print(self.m_name) def add(self, ifile): self.m_list.append(ifile) def remove(self, ifile): self.m_list.remove(ifile) def get_child(self): return self.m_listdef show_tree(root, level): if not root: return for i in range(level): print \"\\t\",#python2.7 打印不换行 # 1、显示根结点 root.display() # 2、若根结点有孩子 # 判读孩子是文件, 显示名字 # 判断孩子是目录, showTree(子目录) mylist = root.get_child() if mylist: # 说明是一个目录 for child in mylist: if not child.get_child(): for i in range(level + 1): print \"\\t\", #python2.7 打印不换行 child.display() else: show_tree(child, level + 1)if __name__ == \"__main__\": root = Dir(\"C\") dir1 = Dir(\"111dir\") aaafile = File(\"aaa.txt\") # 获取root结点下的孩子集合 mylist = root.get_child() root.add(dir1) root.add(aaafile) for child in mylist: child.display() dir222 = Dir(\"222dir\") bbbfile = File(\"bbb.txt\") dir1.add(dir222) dir1.add(bbbfile) print(\"--------showTree---------\") show_tree(root, 0) 源码链接设计模式（九）组合模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（九）组合模式（python_c++实现）/"},{"title":"23种设计模式之（三）抽象工厂模式（Abstract Factory）","text":"本文主要介绍23种设计模式之抽象工厂模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 抽象工厂模式（Abstract Factory）概念抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的。抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，能够创建多个产品族的产品对象。 GoF对抽象工厂模式的定义是：抽闲工厂模式——提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 ##应用场景一系列相互依赖的对象有不同的具体实现，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合。 ##注意事项 抽象工厂模式与工厂模式的主要区别是：工厂模式只能生产一个产品（要么香蕉、要么苹果），抽象工厂可以一下生产一个产品族（里面有很多产品组成）。 代码示例C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/************************************************************************//* 设计模式专题/*/* 抽象工厂模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180914/************************************************************************/#include &lt;iostream&gt;class Fruit{public: virtual void show() = 0;};class AbstractFactory{public: virtual Fruit* CreateBanana() = 0; virtual Fruit* CreateApple() = 0;};class NorthBanana : public Fruit{public: virtual void show() { printf(\"i am an north banana\\n\"); }};class NorthApple : public Fruit{public: virtual void show() { printf(\"i am an north apple\\n\"); }};class SourthBanana : public Fruit{public: virtual void show() { printf(\"i am an sourth banana\\n\"); }};class SourthApple : public Fruit{public: virtual void show() { printf(\"i am an sourth apple\\n\"); }};class NorthFacorty : public AbstractFactory{ virtual Fruit * CreateBanana() { return new NorthBanana; } virtual Fruit * CreateApple() { return new NorthApple; }};class SourthFacorty : public AbstractFactory{ virtual Fruit * CreateBanana() { return new SourthBanana; } virtual Fruit * CreateApple() { return new SourthApple; }};void main(){ Fruit *fruit = NULL; AbstractFactory *af = NULL; ///Sourth af = new SourthFacorty; fruit = af-&gt;CreateApple(); fruit-&gt;show(); delete fruit; fruit = af-&gt;CreateBanana(); fruit-&gt;show(); delete fruit; ///North af = new NorthFacorty; fruit = af-&gt;CreateApple(); fruit-&gt;show(); delete fruit; fruit = af-&gt;CreateBanana(); fruit-&gt;show(); delete fruit; delete af; system(\"pause\"); return ;} python代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 抽象工厂模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180914##################################################################class Fruit(object): def show(self): passclass AbstractFactory(object): def create_banana(self): pass def create_apple(self): passclass NorthBanana(Fruit): def show(self): print(\"i am an north banana\")class NorthApple(Fruit): def show(self): print(\"i am an north apple\")class SourthBanana(Fruit): def show(self): print(\"i am an sourth banana\")class SourthApple(Fruit): def show(self): print(\"i am an sourth apple\")class NorthFacorty(AbstractFactory): def create_banana(self): return NorthBanana() def create_apple(self): return NorthApple()class SourthFacorty(AbstractFactory): def create_banana(self): return SourthBanana() def create_apple(self): return SourthApple()if __name__ == \"__main__\": # Sourth af = SourthFacorty() fruit = af.create_apple() fruit.show() fruit = af.create_banana() fruit.show() # North af = NorthFacorty() fruit = af.create_apple() fruit.show() fruit = af.create_banana() fruit.show() 源码链接设计模式（三）抽象工厂模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（三）抽象工厂模式（python_c++实现）/"},{"title":"23种设计模式之（二十一）状态者模式（State）","text":"本文主要介绍23种设计模式之状态模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 状态模式(State)概念状态模式，是行为设计模式的一种。State模式允许通过改变对象的内部状态而改变对象的行为，这个对象表现得就好像修改了它的类一样。 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转译到表现不同状态的一系列类当中，可以把复杂的判断逻辑简化。 GoF对状态模式的定义是：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 应用场景（1）、行为随状态改变而改变的场景。 （2）、条件、分支语句的代替者。 C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/************************************************************************//* 设计模式专题/*/* 状态模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180918/************************************************************************/#include &lt;iostream&gt;class Worker;class State{public: virtual void doSomeThing(Worker *w) = 0;};class Worker{public: Worker(); int getHour() { return m_hour; } void setHour(int hour) //改变状态 7 { m_hour = hour; } State* getCurrentState() { return m_currstate; } void setCurrentState(State* state) { m_currstate = state; } void doSomeThing() // { m_currstate-&gt;doSomeThing(this); }private: int m_hour; State *m_currstate; //对象的当前状态};class State1 : public State{public: void doSomeThing(Worker *w);};class State2 : public State{public: void doSomeThing(Worker *w);};void State1::doSomeThing(Worker *w){ if (w-&gt;getHour() == 7 || w-&gt;getHour()==8) { printf(\"eat breakfast\\n\"); } else { delete w-&gt;getCurrentState(); //状态1 不满足 要转到状态2 w-&gt;setCurrentState(new State2 ); w-&gt;getCurrentState()-&gt;doSomeThing(w); // }}void State2::doSomeThing(Worker *w){ if (w-&gt;getHour() == 9 || w-&gt;getHour()==10) { printf(\"work \\n\"); } else { delete w-&gt;getCurrentState(); //状态2 不满足 要转到状态3 后者恢复到初始化状态 w-&gt;setCurrentState(new State1); //恢复到当初状态 printf(\"current time %d undefined \\n\" ,w-&gt;getHour()); }}Worker::Worker(){ m_currstate = new State1;}void main(){ Worker *w1 = new Worker; w1-&gt;setHour(7); w1-&gt;doSomeThing(); w1-&gt;setHour(9); w1-&gt;doSomeThing(); delete w1; } python代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 状态模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180918##################################################################class State(object): def do_something(self, worker): passclass Worker(): def __init__(self): self.m_hour = 0 self.m_currstate = State1() def do_something(self): self.m_currstate.do_something(self)class State1(State): def do_something(self, worker): if (worker.m_hour == 7 or worker.m_hour == 8): print(\"eat breakfast\") else: # 状态1不满足要转到状态2 worker.m_currstate = State2() worker.m_currstate.do_something(worker)class State2(State): def do_something(self, worker): if (worker.m_hour == 9 or worker.m_hour == 10): print(\"work\") else: # 状态2不满足要转到状态3后者恢复到初始化状态 worker.m_currstate = State1() # 恢复到当初状态 print(\"current time %d undefined \", worker.m_hour)if __name__ == \"__main__\": worker = Worker() worker.m_hour = 7 worker.do_something() worker.m_hour = 9 worker.do_something() 源码链接设计模式（二十一）状态模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（二十一）状态模式（python_c++实现)/"},{"title":"23种设计模式之（二十三）迭代器模式（Iterator）","text":"本文主要介绍23种设计模式之迭代器模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 迭代器模式(Iterator)概念迭代模式，是行为模式之一，它把对容器中包含的内部对象的访问委让给外部类，使用Iterator（遍历）按顺序进行遍历访问的设计模式。 迭代器模式就是为了有效地处理按顺序进行遍历访问的一种设计模式，简单地说，Iterator模式提供一种有效的方法，可以屏蔽聚集对象集合的容器类的实现细节，而能对容器内包含的对象元素按顺序进行有效的遍历访问。 GoF对迭代器模式的定义是：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 应用场景（1）、访问一个聚合对象的内容而无须暴露它的内部表示。 （2）、需要为聚合对象提供多种遍历方式。 （3）、为遍历不同的聚合结构提供一个统一的接口。 C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/************************************************************************//* 设计模式专题/*/* 迭代器模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180918/************************************************************************/#include &lt;iostream&gt;typedef int Object ;#define SIZE 5 class MyIterator{public: virtual void First() = 0; virtual void Next() = 0; virtual bool IsDone() = 0; virtual Object CurrentItem() = 0;};class Aggregate{public: virtual MyIterator *CreateIterator() = 0; virtual Object getItem(int index) = 0; virtual int getSize() = 0;};class ContreteIterator : public MyIterator{public: ContreteIterator(Aggregate *ag) { _ag = ag; _current_index = 0; } virtual void First() { _current_index = 0; //让当前 游标 回到位置0 } virtual void Next() { if (_current_index &lt; _ag-&gt;getSize()) { _current_index ++; } } virtual bool IsDone() { return (_current_index == _ag-&gt;getSize()); } virtual Object CurrentItem() { return _ag-&gt;getItem(_current_index); }protected:private: int _current_index; Aggregate *_ag;};class ConcreteAggregate : public Aggregate{public: ConcreteAggregate() { for (int i=0; i&lt;SIZE; i++) { object[i] = i + 100; } } virtual MyIterator *CreateIterator() { return new ContreteIterator(this); //让迭代器 持有一个 集合的 引用 } virtual Object getItem(int index) { return object[index]; } virtual int getSize() { return SIZE; }private: Object object[SIZE]; };void main(){ Aggregate * ag = new ConcreteAggregate; MyIterator *it = ag-&gt;CreateIterator(); for (; !(it-&gt;IsDone()); it-&gt;Next() ) { printf (\"%d \",it-&gt;CurrentItem()); } delete it; delete ag;} python代码示例12345678910111213141516171819202122232425262728293031323334353637# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 迭代器模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180918################################################################### python语言本身对可迭代对象有良好的支持，只要对象定义了可以返回一个迭代器的__iter__方法，# 或者定义了可以支持下标索引的__getitem__方法(这些双下划线方法会在其他章节中全面解释)，那么它就是一个可迭代对象。class Aggregate(object): def __init__(self, data): self.data = data self.index = len(data) def __iter__(self): return self def next(self): if self.index == 0: raise StopIteration self.index = self.index - 1 return self.data[self.index]if __name__ == \"__main__\": from collections import Iterable agg = Aggregate([100, 200, 300, 400]) for obj in agg: print(obj) 源码链接设计模式（二十三）迭代器模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（二十三）迭代器模式（python_c++实现)/"},{"title":"23种设计模式之（二）工厂方法模式（Factory Method）","text":"本文主要介绍23种设计模式之工厂方法模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 工厂方法模式（Factory Method）概念工厂方法模式属于类的创建型模式又被称为多态工厂模式 ，工厂方法模式的意义在于定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。 核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 GoF对工厂方法模式的定义是：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。 ##应用场景由于需求的变化，一个类的子类经常面临着剧烈的变化，但他却拥有比较稳定的接口。使用一种封装机制来“隔离这种易变对象的变化”，工厂方法定义一个用于创建对象的接口，让子类来确定创建哪一个具体类的对象，将对象的实例化延迟。 ##代码示例 C++代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include \"stdafx.h\"#include &lt;Windows.h&gt;#include &lt;iostream&gt;/************************************************************************//* 设计模式专题/*/* 工厂方法模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180913/************************************************************************/class Fruit{public: virtual void show() = 0;};class Banana : public Fruit{public: void show() { printf(\"i am an banana\\n\"); }};class Apple : public Fruit{public: void show() { printf(\"i am an apple\\n\"); }};class FruitFactory {public: virtual Fruit *CreateProduct() = 0;};class BananaFactory :public FruitFactory{public: virtual Fruit *CreateProduct() { return new Banana; }};class AppleFactory :public FruitFactory{public: virtual Fruit *CreateProduct() { return new Apple; }};void main(){ FruitFactory *factory = NULL; Fruit *fruit = NULL; //Banana factory = new BananaFactory; fruit = factory-&gt;CreateProduct(); fruit-&gt;show(); delete fruit; delete factory; //Apple factory = new AppleFactory; fruit = factory-&gt;CreateProduct(); fruit-&gt;show(); delete fruit; delete factory;} python代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 工厂方法模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180913##################################################################class Fruit(object): def show(self): passclass Banana(Fruit): def show(self): print(\"i am an banana\")class Apple(Fruit): def show(self): print(\"i am an apple\")class FruitFactory(object): def create_product(self): passclass BananaFactory(FruitFactory): def create_product(self): return Banana()class AppleFactory(FruitFactory): def create_product(self): return Apple()if __name__ == \"__main__\": # Banana factory = BananaFactory() fruit = factory.create_product() fruit.show() factory = AppleFactory() fruit = factory.create_product() fruit.show() 源码链接设计模式(二)工厂方法模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（二）工厂方法模式（python_c++实现）/"},{"title":"23种设计模式之（五）原型模式（Prototype）","text":"本文主要介绍23种设计模式之原型模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 原型模式（Prototype）概念原型模式是一种对象创建型模式，它采取复制原型对象的方法来创建对象的实例，原型模式创建的实例，具有与原型一样的数据： （1）由原型对象自身创建目标对象。也就是说，对象创建这一动作发自原型对象本身。 （2）目标对象是原型对象的一个克隆。也就是说，通过原型模式创建的对象，不仅仅与原型对象具有相同的结构，还与原型对象具有相同的值。 （3）根据对象拷贝层次的不同，有浅拷贝与深拷贝。 GoF对原型模式的定义是：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 ##应用场景用new创建一个对象需要非常繁琐的数据准备或者权限，对象创造过程复杂，由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。 代码示例C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/************************************************************************//* 设计模式专题/*/* 原型模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180915/************************************************************************/ #include &lt;iostream&gt;class PrototypePerson{public: virtual PrototypePerson* clone() = 0; virtual PrototypePerson* deep_clone() = 0; virtual void show() = 0;};class CopyPerson : public PrototypePerson{public: CopyPerson() { m_name = \"\"; m_age = 0; m_resume = NULL; } CopyPerson(std::string name, int age,char * p) { m_name = name; m_age = age; m_resume = new char[strlen(p) + 1]; memset(m_resume,0,strlen(p) + 1); strcpy(m_resume, p); } void setResume(char *p) { if (m_resume != NULL) { delete m_resume; } m_resume = new char[strlen(p) + 1]; memset(m_resume,0,strlen(p) + 1); strcpy(m_resume, p); } virtual void show() { printf(\"m_name:%s \",m_name.c_str()); printf(\"m_age:%d \",m_age); printf(\"m_resume:%s\\n\",m_resume); } virtual CopyPerson* clone() { CopyPerson *tmp = new CopyPerson; *tmp = *this; // 浅拷贝 return tmp; } virtual CopyPerson* deep_clone() { CopyPerson *tmp = new CopyPerson; tmp-&gt;m_name = this-&gt;m_name; tmp-&gt;m_age = this-&gt;m_age; //深拷贝 tmp-&gt;m_resume = new char[strlen(this-&gt;m_resume) + 1]; memset(tmp-&gt;m_resume,0,strlen(this-&gt;m_resume) + 1); strcpy(tmp-&gt;m_resume, this-&gt;m_resume); return tmp; }protected:private: std::string m_name; int m_age ; char *m_resume;};void main(){ CopyPerson * srcPerson = new CopyPerson(\"张三\", 32,\"src_resume\"); printf(\"show src obj : \"); srcPerson-&gt;show(); CopyPerson *dstPerson1 = srcPerson-&gt;clone(); printf(\"show shallow copy obj : \"); dstPerson1-&gt;show(); CopyPerson *dstPerson2 = srcPerson-&gt;deep_clone(); printf(\"show deep copy obj : \"); dstPerson2-&gt;show(); srcPerson-&gt;setResume(\"dst_resume\"); printf(\"------show obj afer change------\\n\"); printf(\"show src obj : \"); srcPerson-&gt;show(); printf(\"show shallow copy obj : \"); dstPerson1-&gt;show(); printf(\"show deep copy obj : \"); dstPerson2-&gt;show();} python代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# -*- coding: utf-8 -*-#################################################################### 设计模式专题## 原型模式## Author : zzl## 编程环境: window10 python2.7## Date : 20180915##################################################################import copyclass PrototypePerson(object): def clone(self): pass def deep_clone(self): pass def show(self): pass# resume类class ResumeObj(object): def __init__(self, resume): self.resume = resume def __str__(self): return self.resumeclass CopyPerson(PrototypePerson): def __init__(self): self.name = \"\" self.age = 0 self.resume = ResumeObj() def __init__(self, name, age, resume): self.m_name = name self.m_age = age self.m_resume = resume def show(self): print(\"m_name:%s m_age:%s m_resume:%s\" % (self.m_name, self.m_age, self.m_resume)) def clone(self): return copy.copy(self) def deep_clone(self): return copy.deepcopy(self)if __name__ == \"__main__\": srcPerson = CopyPerson(u\"张三\", 32, ResumeObj(\"src_resume\")) print(\"show src obj \") srcPerson.show() dstPerson1 = srcPerson.clone() print(\"show shallow copy obj: \") dstPerson1.show() dstPerson2 = srcPerson.deep_clone() print(\"show deep copy obj : \") dstPerson2.show() #change src obj srcPerson.m_resume.resume = \"change\" print(\"------show obj afer change------\") print(\"show src obj: \") srcPerson.show() print(\"show shallow copy obj: \") dstPerson1.show() print(\"show deep copy obj: \") dstPerson2.show() 源码链接设计模式（五）原型模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（五）原型模式（python_c++实现）/"},{"title":"23种设计模式之（二十二）解释器模式（Interpreter）","text":"本文主要介绍23种设计模式之解释器模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 解释器模式(Interpreter)概念解释器模式提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 GoF对解释器模式的定义是：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。 应用场景（1）、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 （2）、一些重复出现的问题可以用一种简单的语言来进行表达。 （3）、一个简单语法需要解释的场景。 C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/************************************************************************//* 设计模式专题/*/* 解释器模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180918/************************************************************************/#include &lt;iostream&gt;class Context{public: Context(int num) { this-&gt;m_num = num; } int getNum() { return m_num; } int getRes() { return m_res; } void setNum(int num) { this-&gt;m_num = num; } void setRes(int res) { this-&gt;m_res = res; }private: int m_num; int m_res;};class Expression{public: virtual void interpreter(Context *context) = 0; };class PlusExpression : public Expression{public: virtual void interpreter(Context *context) { int num = context-&gt;getNum(); num ++; context-&gt;setNum(num); context-&gt;setRes(num); }};class MinusExpression : public Expression{public: virtual void interpreter(Context *context) { int num = context-&gt;getNum(); num -- ; context-&gt;setNum(num); context-&gt;setRes(num); }};void main(){ Expression *expression = NULL; Context *context = NULL; Expression *expression2 = NULL; context = new Context(10); printf(\"%d\\n\",context-&gt;getNum()); expression = new PlusExpression; expression-&gt;interpreter(context); printf(\"%d\\n\",context-&gt;getRes()); expression2 = new MinusExpression; expression2-&gt;interpreter(context); printf(\"%d\\n\",context-&gt;getRes());} python代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 解释器模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180918##################################################################class Context(object): def __init__(self, num): self.m_num = num self.m_res = num def get_num(self): return self.m_num def get_res(self): return self.m_resclass Expression(object): def interpreter(self, context): passclass PlusExpression(Expression): def interpreter(self, context): context.m_num = context.m_num + 1 context.m_res = context.m_numclass MinusExpression(Expression): def interpreter(self, context): context.m_num = context.m_num - 1 context.m_res = context.m_numif __name__ == \"__main__\": context = Context(10) print(context.m_num) expression = PlusExpression() expression.interpreter(context) print(context.m_res) expression2 = MinusExpression() expression2.interpreter(context) print(context.m_res) 源码链接设计模式（二十二）解释模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（二十二）解释器模式（python_c++实现)/"},{"title":"23种设计模式之（六）代理模式（Proxy）","text":"本文主要介绍23种设计模式之代理模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 代理模式（Proxy）概念代理模式是构造型的设计模式之一，它可以为其他对象提供一种代理以控制对这个对象的访问，所谓代理，是指具有与代理元（被代理的对象）具有相同的接口的类，客户端必须通过代理与被代理的目标类交互，而代理一般在交互的过程中（交互前后），进行某些特别的处理。 GoF对代理模式的定义是：为其他对象提供一个代理以控制对这个对象的访问。 ##应用场景 隐藏类，为其提供代理类，对不同的调用者提供不同的调用权限时，可以建立多个代理类来实现，也可以在一个代理类中进行权限判断来进行不同权限的功能调用，扩展类的某个功能而不改变原类的代码也可以使用代理模式，在代理类中进行扩展。 代码示例C++代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/************************************************************************//* 设计模式专题/*/* 代理模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180915/************************************************************************/#include &lt;iostream&gt;class Subject{public: virtual void sellBook() = 0;};class RealSubjectBook : public Subject{public: virtual void sellBook() { printf(\"sell book\\n\"); }};//a中包含b类；a、b类实现协议类protocol class dangdangProxy : public Subject{public: dangdangProxy() { m_subject = new RealSubjectBook; } virtual void sellBook() { discountSell(); m_subject-&gt;sellBook(); discountSell(); } void discountSell() { printf(\"sell book at a discount\\n\"); }private: Subject *m_subject;};void main(){ Subject *s = new dangdangProxy; s-&gt;sellBook(); delete s;} python代码示例12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 代理模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180915##################################################################class Subject(object): def sell_book(self): passclass RealSubjectBook(Subject): def sell_book(self): print(\"sell book\")# a中包含b类；a、b类实现协议类protocolclass dangdangProxy(Subject): def __init__(self): self.m_subject = RealSubjectBook() def sell_book(self): self.discountSell() self.m_subject.sell_book() self.discountSell() def discountSell(self): print(\"sell book at a discount\")if __name__ == \"__main__\": subject = dangdangProxy() subject.sell_book() 源码链接设计模式（六）代理模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（六）代理模式（python_c++实现）/"},{"title":"23种设计模式之（八）适配器模式（Adapter）","text":"本文主要介绍23种设计模式之适配器模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 适配器模式（Adapter）概念适配器模式，是构造型模式之一，通过Adapter模式可以改变已有类（或外部类）的接口形式。 GoF对适配器模式的定义是：将一个类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 ##应用场景 （1）想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。 （2）我们有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。 （3）想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。这个抽象类就是适配器。 代码示例C++代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/************************************************************************//* 设计模式专题/*/* 适配器模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180915/************************************************************************/#include &lt;iostream&gt;// Current18 // Current220// Adapter class Current18v{public: virtual void useCurrent18v() = 0;};class Current220v{public: void useCurrent220v() { printf(\"i am 220v,welcome to use\\n\"); }};class Adapter : public Current18v{public: Adapter(Current220v *current) { m_current = current; } virtual void useCurrent18v() { printf(\"i am 18v adpter , i can adpte 220v \\n\"); m_current-&gt;useCurrent220v(); }private: Current220v *m_current;};void main(){ Current220v *current220v = NULL; Adapter *adapter = NULL; current220v = new Current220v; adapter = new Adapter(current220v); adapter-&gt;useCurrent18v(); delete current220v ; delete adapter;} python代码示例12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 适配器模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180915################################################################### Current18# Current220# Adapterclass Current18v(object): def use_current18v(self): passclass Current220v(object): def use_current220v(self): print(\"i am 220v,welcome to use\\n\")class Adapter(Current18v): def __init__(self, current): self.m_current = current def use_current18v(self): print(\"i am 18v adpter , i can adpte 220v\") self.m_current.use_current220v()if __name__ == \"__main__\": current220v = Current220v() adapter = Adapter(current220v) adapter.use_current18v() 源码链接设计模式（八）适配器模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（八）适配器模式（python_c++实现）/"},{"title":"23种设计模式之（二十）访问者模式（Visitor）","text":"本文主要介绍23种设计模式之访问者模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 访问者模式(Visitor)概念在访问者模式（Visitor）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 GoF对访问者模式的定义是：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 应用场景（1）、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 （2）、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。 C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/************************************************************************//* 设计模式专题/*/* 访问者模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180918/************************************************************************/#include &lt;iostream&gt;using namespace std;#include \"list\"// Visitor ParkElementclass ParkElement;class Visitor{public: virtual void visit(ParkElement *parkelement) = 0;};class ParkElement{public: virtual void accept(Visitor *visit) = 0;};class ParkA : public ParkElement{public: virtual void accept(Visitor *v) { v-&gt;visit(this); //公园接受访问者访问 让访问者做操作 }};class ParkB : public ParkElement{public: virtual void accept(Visitor *v) { v-&gt;visit(this); //公园接受访问者访问 让访问者做操作 }};//整个公园 class Park : public ParkElement{public: Park() { m_list.clear(); } void setParkElement(ParkElement *pe) { m_list.push_back(pe); }public: virtual void accept(Visitor *v) { //v-&gt;visit(this); //公园接受访问者访问 让访问者做操作 for (list&lt;ParkElement *&gt;::iterator it = m_list.begin(); it!=m_list.end(); it++ ) { (*it)-&gt;accept(v); //公园A 公园B 接受 管理者v访问 } }private: list&lt;ParkElement *&gt; m_list; //公园的每一部分 //应该让公园的每一个部分 都让 管理者访问};class VisitorA : public Visitor{public: virtual void visit(ParkElement *parkelement) { printf(\"cleaner a clear A part of the park \\n\"); }};class VisitorB : public Visitor{public: virtual void visit(ParkElement *parkelement) { printf(\"cleaner b clear B part of the park \\n\"); }};class ManagerVisitor : public Visitor{public: virtual void visit(ParkElement *parkelement) { printf(\"manager visit whole park \\n\"); }};void main(){ Visitor *vA = new VisitorA; Visitor *vB = new VisitorB; ParkA *parkA = new ParkA; ParkB *parkB = new ParkB; //清洁者打扫 parkA-&gt;accept(vA); parkB-&gt;accept(vB); Visitor *vManager = new ManagerVisitor ; Park *park = new Park; park-&gt;setParkElement(parkA); park-&gt;setParkElement(parkB); //整个公园 接受 管理者访问 park-&gt;accept(vManager); delete vA; delete vB; delete parkA; delete parkB; delete park; delete vManager;} python代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 访问者模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180918##################################################################class Visitor(object): def visit(self, park_element): passclass ParkElement(object): def accept(self, visit): passclass ParkA(ParkElement): def accept(self, vister): vister.visit(self) # 公园接受访问者访问让访问者做操作class ParkB(ParkElement): def accept(self, vister): vister.visit(self) # 公园接受访问者访问让访问者做操作# 整个公园class Park(ParkElement): def __init__(self): self.m_list = [] def add_park_element(self, element): self.m_list.append(element) def accept(self, visitor): for each_vistitor in self.m_list: each_vistitor.accept(visitor) # 公园A 公园B 接受 管理者v访问class VisitorA(Visitor): def visit(self, park_element): print(\"cleaner a clear A part of the park\")class VisitorB(Visitor): def visit(self, park_element): print(\"cleaner b clear B part of the park\")class ManagerVisitor(Visitor): def visit(self, park_element): print(\"manager visit whole park\")if __name__ == \"__main__\": visitorA = VisitorA() visitorB = VisitorB() parkA = ParkA() parkB = ParkB() # 清洁者打扫 parkA.accept(visitorA) parkB.accept(visitorB) vManager = ManagerVisitor() park = Park() park.add_park_element(parkA) park.add_park_element(parkB) # 整个公园接受管理者访问 park.accept(vManager) 源码链接设计模式（二十）访问者模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（二十）访问者模式（python_c++实现)/"},{"title":"23种设计模式之（十七）中介者模式（Mediator）","text":"本文主要介绍23种设计模式之中介者模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 中介者模式(Mediator)概念中介者模式是行为模式之一，在Mediator模式中，类之间的交互行为被统一放在Mediator的对象中，对象通过Mediator对象同其他对象交互，Mediator对象起着控制器的作用，是用来降低多个对象和类之间的通信复杂性，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。 GoF对中介者模式的定义是：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 应用场景（1）、 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 （2）、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/************************************************************************//* 设计模式专题/*/* 备忘录模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180918/************************************************************************/#include &lt;iostream&gt;#include \"string\"//Caretaker 管理者// MememTo 备忘录class MememTo{public: MememTo(std::string name,int age ) { m_name = name; m_age = age; } std::string getName() { return m_name; } int getAge() { return m_age; } void setName(std::string name) { this-&gt;m_name = name; } void setAge(int age) { this-&gt;m_age = age; }private: std::string m_name; int m_age;};class Person{public: Person(std::string name,int age ) { m_name = name; m_age = age; } std::string getName() { return m_name; } int getAge() { return m_age; } void setName(std::string name) { this-&gt;m_name = name; } void setAge(int age) { this-&gt;m_age = age; } //保存 MememTo* createMememTo() { return new MememTo(m_name, m_age); } //还原 void setMememTo(MememTo* memto) { this-&gt;m_age = memto-&gt;getAge(); this-&gt;m_name = memto-&gt;getName(); }public: void printT() { printf (\"m_name:%s m_age:%d \" ,m_name.c_str(),m_age ); }private: std::string m_name; int m_age;};class Caretaker{public: Caretaker(MememTo *memto) { this-&gt;memto = memto; } MememTo *getMememTo() { return memto; } void setMememTo(MememTo *memto) { this-&gt;memto = memto; }protected:private: MememTo *memto;};void main(){ //MememTo *memto = NULL; Caretaker *caretaker = NULL; Person *p = new Person(\"张三\", 32); p-&gt;printT(); //创建 Person对象的一个状态 printf(\"---------\\n\"); caretaker = new Caretaker( p-&gt;createMememTo()); p-&gt;setAge(42); p-&gt;printT(); printf(\"还原旧的状态\\n\" ); p-&gt;setMememTo(caretaker-&gt;getMememTo()); p-&gt;printT(); delete caretaker; delete p;} python代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 备忘录模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180918##################################################################class MememTo(object): def __init__(self, name, age): self.m_name = name self.m_age = age;class Person(object): def __init__(self, name, age): self.m_name = name self.m_age = age # 创建 def create_mememto(self): return MememTo(self.m_name, self.m_age) # 还原 def set_mememto(self, memto): self.m_age = memto.m_age self.m_name = memto.m_name def show(self): print(\"m_name:%s m_age:%s \" % (self.m_name, self.m_age))class Caretaker(object): def __init__(self, memto): self.memto = memto def get_mememto(self): return self.memto def set_mememto(self, memto): self.memto = memtoif __name__ == \"__main__\": p = Person(\"张三\", 32) p.show() # 创建Person对象的一个状态 print(\"---------\") caretaker = Caretaker(p.create_mememto()) p.m_age = 42 p.show() print(\"还原旧的状态\") p.set_mememto(caretaker.get_mememto()) p.show() 源码链接设计模式（十七）中介者模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（十七）中介者模式（python_c++实现)/"},{"title":"23种设计模式之（十一）外观模式（Facade）","text":"本文主要介绍23种设计模式之外观模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 外观模式（Facade）概念外观模式，Facade模式为一组具有类似功能的类群，比如类库，子系统等等，提供一个一致的简单的界面,这个一致的简单的界面被称作facade，它向现有的系统添加一个接口，来隐藏系统的复杂性，这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 GoF对外观模式的定义是：为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 ##应用场景 （1）、为复杂的模块或子系统提供外界访问的模块。 （ 2）、子系统相对独立。 代码示例C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/************************************************************************//* 设计模式专题/*/* 外观模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180916/************************************************************************/#include &lt;iostream&gt;class SubSystemA{public: void doThing() { printf(\"SubSystemA run\\n\" ); }};class SubSystemB{public: void doThing() { printf(\"SubSystemB run\\n\" ); }};class SubSystemC{public: void doThing() { printf(\"SubSystemC run\\n\" ); }};class Facade{public: Facade() { sysA = new SubSystemA; sysB = new SubSystemB; sysC = new SubSystemC; } ~Facade() { delete sysA; delete sysB; delete sysC; }public: void doThing() { sysA-&gt;doThing(); sysB-&gt;doThing(); sysC-&gt;doThing(); }protected:private: SubSystemA *sysA; SubSystemB *sysB; SubSystemC *sysC;};void main(){ Facade *f = new Facade; f-&gt;doThing(); delete f;} python代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 外观模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180916##################################################################class SubSystemA(object): def do_thing(self): print(\"SubSystemA run\")class SubSystemB(object): def do_thing(self): print(\"SubSystemB run\")class SubSystemC(object): def do_thing(self): print(\"SubSystemC run\")class Facade(object): def __init__(self): self.sysA = SubSystemA() self.sysB = SubSystemB() self.sysC = SubSystemC() def do_thing(self): self.sysA.do_thing() self.sysB.do_thing() self.sysC.do_thing()if __name__ == \"__main__\": f = Facade() f.do_thing() 源码链接设计模式（十一）外观模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（十一）外观模式（python_c++实现）/"},{"title":"23种设计模式之（十二）享元模式（Flyweight）","text":"本文主要介绍23种设计模式之享元模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 #享元模式（Flyweight） ##概念 享元模式主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式，尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。 GoF对享元模式的定义是：运用共享技术有效地支持大量细粒度的对象。 ##应用场景 （1）、系统有大量相似对象。 （ 2）、需要缓冲池的场景。 ##代码示例 ###C++代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/************************************************************************//* 设计模式专题/*/* 外观模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180916/************************************************************************/#include &lt;iostream&gt;class SubSystemA{public: void doThing() { printf(\"SubSystemA run\\n\" ); }};class SubSystemB{public: void doThing() { printf(\"SubSystemB run\\n\" ); }};class SubSystemC{public: void doThing() { printf(\"SubSystemC run\\n\" ); }};class Facade{public: Facade() { sysA = new SubSystemA; sysB = new SubSystemB; sysC = new SubSystemC; } ~Facade() { delete sysA; delete sysB; delete sysC; }public: void doThing() { sysA-&gt;doThing(); sysB-&gt;doThing(); sysC-&gt;doThing(); }protected:private: SubSystemA *sysA; SubSystemB *sysB; SubSystemC *sysC;};void main(){ Facade *f = new Facade; f-&gt;doThing(); delete f;} ###python代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 外观模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180916##################################################################class SubSystemA(object): def do_thing(self): print(\"SubSystemA run\")class SubSystemB(object): def do_thing(self): print(\"SubSystemB run\")class SubSystemC(object): def do_thing(self): print(\"SubSystemC run\")class Facade(object): def __init__(self): self.sysA = SubSystemA() self.sysB = SubSystemB() self.sysC = SubSystemC() def do_thing(self): self.sysA.do_thing() self.sysB.do_thing() self.sysC.do_thing()if __name__ == \"__main__\": f = Facade() f.do_thing() ##源码链接设计模式（十二）享元模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（十二）享元模式（python_c++实现）/"},{"title":"23种设计模式之（十九）备忘录模式（Memento）","text":"本文主要介绍23种设计模式之备忘录模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 备忘录模式(Memento)概念备忘录模式，是行为模式之一，它的作用是保存对象的内部状态，并在需要的时候（undo/rollback）恢复对象以前的状态。 GoF对备忘录模式的定义是：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 应用场景（1）、 需要保存/恢复数据的相关状态场景。（2）、 提供一个可回滚的操作。对象之间的耦合度。 C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/************************************************************************//* 设计模式专题/*/* 备忘录模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180918/************************************************************************/#include &lt;iostream&gt;#include \"string\"//Caretaker 管理者// MememTo 备忘录class MememTo{public: MememTo(std::string name,int age ) { m_name = name; m_age = age; } std::string getName() { return m_name; } int getAge() { return m_age; } void setName(std::string name) { this-&gt;m_name = name; } void setAge(int age) { this-&gt;m_age = age; }private: std::string m_name; int m_age;};class Person{public: Person(std::string name,int age ) { m_name = name; m_age = age; } std::string getName() { return m_name; } int getAge() { return m_age; } void setName(std::string name) { this-&gt;m_name = name; } void setAge(int age) { this-&gt;m_age = age; } //保存 MememTo* createMememTo() { return new MememTo(m_name, m_age); } //还原 void setMememTo(MememTo* memto) { this-&gt;m_age = memto-&gt;getAge(); this-&gt;m_name = memto-&gt;getName(); }public: void printT() { printf (\"m_name:%s m_age:%d \" ,m_name.c_str(),m_age ); }private: std::string m_name; int m_age;};class Caretaker{public: Caretaker(MememTo *memto) { this-&gt;memto = memto; } MememTo *getMememTo() { return memto; } void setMememTo(MememTo *memto) { this-&gt;memto = memto; }protected:private: MememTo *memto;};void main(){ //MememTo *memto = NULL; Caretaker *caretaker = NULL; Person *p = new Person(\"张三\", 32); p-&gt;printT(); //创建 Person对象的一个状态 printf(\"---------\\n\"); caretaker = new Caretaker( p-&gt;createMememTo()); p-&gt;setAge(42); p-&gt;printT(); printf(\"还原旧的状态\\n\" ); p-&gt;setMememTo(caretaker-&gt;getMememTo()); p-&gt;printT(); delete caretaker; delete p;} python代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 备忘录模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180918##################################################################class MememTo(object): def __init__(self, name, age): self.m_name = name self.m_age = age;class Person(object): def __init__(self, name, age): self.m_name = name self.m_age = age # 创建 def create_mememto(self): return MememTo(self.m_name, self.m_age) # 还原 def set_mememto(self, memto): self.m_age = memto.m_age self.m_name = memto.m_name def show(self): print(\"m_name:%s m_age:%s \" % (self.m_name, self.m_age))class Caretaker(object): def __init__(self, memto): self.memto = memto def get_mememto(self): return self.memto def set_mememto(self, memto): self.memto = memtoif __name__ == \"__main__\": p = Person(\"张三\", 32) p.show() # 创建Person对象的一个状态 print(\"---------\") caretaker = Caretaker(p.create_mememto()) p.m_age = 42 p.show() print(\"还原旧的状态\") p.set_mememto(caretaker.get_mememto()) p.show() 源码链接设计模式（十九）备忘录模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（十九）备忘录模式（python_c++实现)/"},{"title":"23种设计模式之（十三）模板模式（TemplateMethod）","text":"本文主要介绍23种设计模式之模板模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 模板模式（TemplateMethod）概念模板模式，是行为模式之一，它把具有特定步骤算法中的某些必要的处理委让给抽象方法，通过子类继承对抽象方法的不同实现改变整个算法的行为，它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。 GoF对模板模式的定义是：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 应用场景（1）、 有多个子类共有的方法，且逻辑相同。 （ 2）、重要的、复杂的方法，可以考虑作为模板方法。 代码示例C++代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/************************************************************************//* 设计模式专题/*/* 模板模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180916/************************************************************************/#include &lt;iostream&gt;class MakeCar{public: virtual void MakeHead() = 0; virtual void MakeBody() = 0; virtual void MakeTail() = 0;public: void Make() //模板函数 把业务逻辑给做好 { MakeTail(); MakeBody(); MakeHead(); }};//class Jeep : public MakeCar{public: virtual void MakeHead() { printf(\"jeep head\\n\"); } virtual void MakeBody() { printf(\"jeep body\\n\"); } virtual void MakeTail() { printf(\"jeep tail\\n\"); }};class Bus : public MakeCar{public: virtual void MakeHead() { printf(\"Bus head\\n\"); } virtual void MakeBody() { printf(\"Bus head\\n\"); } virtual void MakeTail() { printf(\"Bus head\\n\"); }};void main(){ MakeCar *car = new Bus; car-&gt;Make(); delete car; MakeCar *car2 = new Jeep; car2-&gt;Make(); delete car2;} python代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 模板模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180916##################################################################class MakeCar(object): def make_head(self): pass def make_body(self): pass def make_tail(self): pass # 模板函数把业务逻辑给做好 def make(self): self.make_tail() self.make_head() self.make_body()class Jeep(MakeCar): def make_head(self): print(\"jeep head\") def make_body(self): print(\"jeep body\") def make_tail(self): print(\"jeep tail\")class Bus(MakeCar): def make_head(self): print(\"bus head\") def make_body(self): print(\"bus body\") def make_tail(self): print(\"bus tail\")if __name__ == \"__main__\": bus = Bus() bus.make() jeep = Jeep() jeep.make() 源码链接设计模式（十三）模板模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（十三）模板模式（python_c++实现）/"},{"title":"23种设计模式之（十五）责任链模式（Chain of Responsibility ）","text":"本文主要介绍23种设计模式之责任链模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 责任链模式(Chain of Responsibility )概念责任链模式或者职责连模式，是行为模式之一，该模式构造一系列分别担当不同的职责的类的对象来共同完成一个任务，这些类的对象之间像链条一样紧密相连，所以被称作职责链模式。 GoF对责任链模式的定义是：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。 应用场景（1）、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 （2）、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 （3）、可动态指定一组对象处理请求。 代码示例C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/************************************************************************//* 设计模式专题/*/* 责任链模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180918/************************************************************************/#include &lt;iostream&gt;using namespace std;//造完车 以后,需要把任务 传递下去class CarHandle{public: virtual void HandleCar() = 0; CarHandle *setNextHandle(CarHandle *handle) { m_handle = handle; return m_handle; }protected: CarHandle *m_handle; //下一个处理单元};class HeadCarHandle : public CarHandle{public: virtual void HandleCar() { printf(\"make car head\\n\"); //造 玩车头 以后 把任务递交给 下一个处理者 if (m_handle != NULL) { m_handle-&gt;HandleCar(); // } }};class BodyCarHandle : public CarHandle{public: virtual void HandleCar() { printf(\"make car body\\n\"); //造 造 车身 以后 把任务递交给 下一个处理者 if (m_handle != NULL) { m_handle-&gt;HandleCar(); // } }};class TailCarHandle : public CarHandle{public: virtual void HandleCar() { printf(\"make car tail\\n\"); //造 造车尾 以后 把任务递交给 下一个处理者 if (m_handle != NULL) { m_handle-&gt;HandleCar(); // } }};void main(){ CarHandle *headHandle = new HeadCarHandle; CarHandle *bodyHandle = new BodyCarHandle; CarHandle *tailHandle = new TailCarHandle; headHandle-&gt;setNextHandle(tailHandle); tailHandle-&gt;setNextHandle(bodyHandle); bodyHandle-&gt;setNextHandle(NULL); headHandle-&gt;HandleCar(); delete headHandle; delete bodyHandle; delete tailHandle;} python代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 责任链模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180918################################################################### 造完车以后, 需要把任务传递下去class CarHandle(object): def __init__(self): self.m_next_handle = None def handcar(self): passclass HeadCarHandle(CarHandle): def handcar(self): print(\"make car head\") # 造玩车头以后把任务递交给下一个处理者 if self.m_next_handle: self.m_next_handle.handcar()class BodyCarHandle(CarHandle): def handcar(self): print(\"make car body \") # 造玩车身以后把任务递交给下一个处理者 if self.m_next_handle: self.m_next_handle.handcar()class TailCarHandle(CarHandle): def handcar(self): print(\"make car tail \") # 造玩车身以后把任务递交给下一个处理者 if self.m_next_handle: self.m_next_handle.handcar()if __name__ == \"__main__\": headHandle = HeadCarHandle() bodyHandle = BodyCarHandle() tailHandle = TailCarHandle() headHandle.m_next_handle = tailHandle tailHandle.m_next_handle = bodyHandle bodyHandle.m_next_handle = None headHandle.handcar() 源码链接设计模式（十五）责任链模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（十五）责任链模式（python_c++实现)/"},{"title":"23种设计模式之（十八）观察者模式（Observer）","text":"本文主要介绍23种设计模式之观察者模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 观察者模式(Observer)概念观察者模式是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态。 观察者模式提供给关联对象一种同步通信的手段，使某个对象与依赖它的其他对象之间保持状态同步。 GoF对观察者模式的定义是：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。 应用场景（1）、 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。（2）、一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。（3）、一个对象必须通知其他对象，而并不知道这些对象是谁。 C++代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/************************************************************************//* 设计模式专题/*/* 观察者模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180918/************************************************************************/#include &lt;iostream&gt;#include \"string\"#include \"list\"class Secretary;//观察者 class PlayserObserver{public: PlayserObserver(Secretary *secretary) { this-&gt;m_secretary = secretary; } void update(std::string action) { printf(\"action:%s\\n\",action.c_str()); }private: Secretary *m_secretary;};//class Secretary{public: Secretary() { m_list.clear(); } void Notify(std::string info) { //给所有的 观察者 发送 情报 for ( std::list&lt;PlayserObserver *&gt;::iterator it=m_list.begin(); it!=m_list.end(); it++) { (*it)-&gt;update(info); } } void setPlayserObserver(PlayserObserver *o) { m_list.push_back(o); }private: std::list&lt;PlayserObserver *&gt; m_list;};void main(){ Secretary *secretary = NULL; PlayserObserver *po1 = NULL; PlayserObserver *po2 = NULL; secretary = new Secretary; po1 = new PlayserObserver(secretary); po2 = new PlayserObserver(secretary); secretary-&gt;setPlayserObserver(po1); secretary-&gt;setPlayserObserver(po2); secretary-&gt;Notify(\"boss come \") ; secretary-&gt;Notify(\"boss gone \"); delete secretary ; delete po1 ; delete po2 ;} python代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 观察者模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180918################################################################### 观察者class PlayserObserver(object): def __init__(self, secretary): self.m_secretary = secretary def update(self, action): print(\"action:%s\" % action)class Secretary(object): def __init__(self): self.m_list = [] def show_notify(self, info): # 给所有的 观察者 发送 情报 for every in self.m_list: every.update(info) def set_playser_observer(self, observer): self.m_list.append(observer)if __name__ == \"__main__\": secretary = Secretary() po1 = PlayserObserver(secretary) po2 = PlayserObserver(secretary) secretary.set_playser_observer(po1) secretary.set_playser_observer(po2) secretary.show_notify(\"boss come \") secretary.show_notify(\"boss gone \") 源码链接设计模式（十八）观察者模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（十八）观察者模式（python_c++实现)/"},{"title":"23种设计模式之（十六）策略模式（Strategy ）","text":"本文主要介绍23种设计模式之策略模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 策略模式(Strategy)概念策略模式是行为模式之一，它对一系列的算法加以封装，为所有算法定义一个抽象的算法接口，并通过继承该抽象算法接口对所有的算法加以封装和实现，具体的算法选择交由客户端决定（策略），Strategy模式主要用来平滑地处理算法的切换 。 GoF对策略模式的定义是：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。 应用场景（1）、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 （2）、一个系统需要动态地在几种算法中选择一种。 （3）、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/************************************************************************//* 设计模式专题/*/* 策略模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180918/************************************************************************/#include &lt;iostream&gt;class Strategy{public: virtual void crypt() = 0;};class AES : public Strategy{public: virtual void crypt() { printf(\"AES encrypt\\n\" ); }};class DES : public Strategy{public: virtual void crypt() { printf(\"DES encrypt\\n\" ); }};class Context{public: void setStrategy(Strategy *strategy) { this-&gt;strategy = strategy; } void test_encrypt() { strategy-&gt;crypt(); }protected:private: Strategy *strategy;};void main(){ Strategy *strategy = NULL; //strategy = new DES; strategy = new AES; Context *context = new Context; context-&gt;setStrategy(strategy); context-&gt;test_encrypt(); delete strategy; delete context;} python代码示例123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 策略模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180918##################################################################class Strategy(object): def crypt(self): passclass AES(Strategy): def crypt(self): print(\"AES encrypt\")class DES(Strategy): def crypt(self): print(\"DES encrypt\")class Context(object): def __init__(self): self.m_strategy = None def test_encrypt(self): self.m_strategy.crypt()if __name__ == \"__main__\": strategy = DES() #strategy = AES() context = Context() context.m_strategy = strategy context.test_encrypt() 源码链接设计模式（十六）策略模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（十六）策略模式（python_c++实现)/"},{"title":"23种设计模式之（十四）命令模式（Command）","text":"本文主要介绍23种设计模式之命令模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 命令模式(Command)概念命令模式是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 在面向对象的程序设计中，一个对象调用另一个对象，一般情况下的调用过程是,创建目标对象实例,设置调用参数,调用目标对象的方法。但在有些情况下有必要使用一个专门的类对这种调用过程加以封装，我们把这种专门的类称作command类,整个调用过程比较繁杂，或者存在多处这种调用。这时，使用Command类对该调用加以封装，便于功能的再利用。 GoF对命令模式的定义是：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 ##应用场景（1）、认为是命令的地方都可以使用命令模式，比如GUI 中每一个按钮都是一条命令。 （ 2）、模拟 CMD。 代码示例C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/************************************************************************//* 设计模式专题/*/* 命令模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180917/************************************************************************/#include &lt;iostream&gt;#include \"list\"class Doctor{public: void treat_eye() { printf(\"treat eye \\n\"); } void treat_nose() { printf(\"treat nose \\n\"); }};class Command{public: virtual void treat() = 0;};class CommandTreatEye : public Command{public: CommandTreatEye(Doctor *doctor) { m_doctor = doctor; } void treat() { m_doctor-&gt;treat_eye(); }private: Doctor *m_doctor;};class CommandTreatNose : public Command{public: CommandTreatNose(Doctor *doctor) { m_doctor = doctor; } void treat() { m_doctor-&gt;treat_nose(); }private: Doctor *m_doctor;};class BeautyNurse{public: BeautyNurse(Command *command) { this-&gt;command = command; }public: void SubmittedCase() //提交病例 下单命令 { command-&gt;treat(); }protected:private: Command *command;};//护士长class HeadNurse {public: HeadNurse() { m_list.clear(); }public: void setCommand(Command *command) { m_list.push_back(command); } void SubmittedCase() //提交病例 下单命令 { for (std::list&lt;Command *&gt;::iterator it=m_list.begin(); it!=m_list.end(); it++) { (*it)-&gt;treat(); } }private: std::list&lt;Command *&gt; m_list;};void main(){ //护士提交简历 给以上看病 HeadNurse *headnurse = NULL; Doctor *doctor = NULL; Command *command1 = NULL; Command *command2 = NULL; doctor = new Doctor ; command1 = new CommandTreatEye(doctor); command2 = new CommandTreatNose(doctor); headnurse = new HeadNurse(); //new 护士长 headnurse-&gt;setCommand(command1); headnurse-&gt;setCommand(command2); headnurse-&gt;SubmittedCase(); // 护士长 批量下单命令 delete doctor; delete command1; delete command2; delete headnurse;} python代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 命令模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180917##################################################################class Doctor(object): def treat_eye(self): print(\"treat eye\") def treat_nose(self): print(\"treat nose\")class Command(object): def treat(self): passclass CommandTreatEye(Command): def __init__(self, doctor): self.m_doctor = doctor def treat(self): self.m_doctor.treat_eye()class CommandTreatNose(Command): def __init__(self, doctor): self.m_doctor = doctor def treat(self): self.m_doctor.treat_nose()class BeautyNurse(object): def __init__(self, command): self.m_command = command def submitted_case(self): self.m_command.treat()class HeadNurse(object): def __init__(self): self.m_list = [] def add_command(self, command): self.m_list.append(command) def submitted_case(self): for command in self.m_list: command.treat()if __name__ == \"__main__\": # 护士提交简历给医生看病 doctor = Doctor() command1 = CommandTreatEye(doctor) command2 = CommandTreatNose(doctor) head_nurse = HeadNurse() head_nurse.add_command(command1) head_nurse.add_command(command2) head_nurse.submitted_case() 源码链接设计模式（十四）命令模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（十四）命令模式（python_c++实现）/"},{"title":"23种设计模式之（十）桥接模式（Bridge）","text":"本文主要介绍23种设计模式之组合模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 桥接模式（Bridge）概念桥接模式，是构造型的设计模式之一。Bridge模式基于类的最小设计原则，通过使用封装，聚合以及继承等行为来让不同的类承担不同的责任。它的主要特点是把抽象（abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对它们的功能扩展。 GoF对桥接模式的定义是：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 ##应用场景 （1）如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 （2）对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 （3）一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 代码示例C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/************************************************************************//* 设计模式专题/*/* 桥接模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180916/************************************************************************/#include &lt;iostream&gt;class Engine{public: virtual void InstallEngine() = 0;};class Engine4400cc : public Engine{public: virtual void InstallEngine() { printf(\"i am 4400cc engine ,i am installed successful\\n\"); }};class Engine4500cc : public Engine{public: virtual void InstallEngine() { printf(\"i am 4500cc engine ,i am installed successful\\n\"); }};class Car{public: Car(Engine *engine) { this-&gt;m_engine = engine; } virtual void installEngine() = 0;protected: Engine *m_engine;};class WBM5 : public Car{public: WBM5(Engine *engine) : Car(engine) { ; } virtual void installEngine() { printf(\"i am WBM5 \\n\"); m_engine-&gt;InstallEngine(); }};class WBM6 : public Car{public: WBM6(Engine *engine) : Car(engine) { ; } virtual void installEngine() { printf(\"i am WBM6 \\n\"); m_engine-&gt;InstallEngine(); }};void main(){ // Engine *engine = NULL; WBM6 *wbm6 = NULL; WBM5 *wbm5 = NULL; engine = new Engine4400cc; wbm6 = new WBM6(engine); wbm6-&gt;installEngine(); wbm5 = new WBM5(engine); wbm5-&gt;installEngine(); delete wbm6; delete wbm5; delete engine; } python代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 桥接模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180916##################################################################class Engine(object): def install_engine(self): passclass Engine4400cc(Engine): def install_engine(self): print(\"i am 4400cc engine ,i am installed successful\")class Engine4500cc(Engine): def install_engine(self): print(\"i am 4500cc engine ,i am installed successful\")class Car(object): def __init__(self): self.m_engine = engine def install_engine(self): passclass WBM5(Car): def __init__(self, engine): self.m_engine = engine def install_engine(self): print(\"i am WBM5 \") self.m_engine.install_engine()class WBM6(Car): def __init__(self, engine): self.m_engine = engine def install_engine(self): print(\"i am WBM6 \") self.m_engine.install_engine()if __name__ == \"__main__\": engine = Engine4400cc() wbm6 = WBM6(engine) wbm6.install_engine(); wbm5 = WBM5(engine); wbm5.install_engine() 源码链接设计模式（十）组合模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（十）桥接模式（python_c++实现）/"},{"title":"23种设计模式之（四）建造者模式（Builder）","text":"本文主要介绍23种设计模式之建造者模式，附详细python/c++示例代码。 概念 应用场景 注意事项 代码示例 总结 代码链接 建造者模式（Builder）概念建造者模式是一种对象创建型模式之一，用来隐藏复合对象的创建过程，它把复合对象的创建过程加以抽象，通过子类继承和重载的方式，动态地创建具有复合属性的对象。 建造者模式是为对象的创建而设计的模式：（1）创建的是一个复合对象，被创建的对象为一个具有复合属性的复合对象 ；（2）关注对象创建的各部分的创建过程，不同的工厂对产品属性有不同的创建方法 GoF对建造者模式的定义是：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 ##应用场景一个类的各个组成部分的具体实现类或者算法经常面临着变化，但是将他们组合在一起的算法却相对稳定，提供一种封装机制 将稳定的组合算法于易变的各个组成部分隔离开来。 代码示例C++代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180/************************************************************************//* 设计模式专题/*/* 建造者模式/*/* Author : zzl/*/* 编程环境: window10 vs2010/*/* Date : 20180914/************************************************************************/#include &lt;iostream&gt;#include \"string\"class House{public: void setDoor(std::string door) { this-&gt;m_door = door; } void setWall(std::string wall) { this-&gt;m_wall = wall; } void setWindow(std::string window) { this-&gt;m_window = window; } std::string getDoor( ) { printf(\"%s\\n\",m_door.c_str()); return this-&gt;m_door ; } std::string getWall() { printf(\"%s\\n\",m_wall.c_str()); return this-&gt;m_wall; } std::string getWindow() { printf(\"%s\\n\",m_window.c_str()); return m_window; }private: std::string m_door; std::string m_wall; std::string m_window;};class Builder{public: virtual void buildWall() = 0; virtual void buildDoor() = 0; virtual void buildWindow() = 0; virtual House* getHouse() = 0;};//公寓工程队class FlatBuilder : public Builder{public: FlatBuilder() { m_house = new House; } virtual void buildWall() { m_house-&gt;setWall(\" flat wall\"); } virtual void buildDoor() { m_house-&gt;setDoor(\"flat door\"); } virtual void buildWindow() { m_house-&gt;setWindow(\"flat window\"); } virtual House* getHouse() { return m_house; }private: House *m_house;};//别墅 villa 工程队class VillaBuilder : public Builder{public: VillaBuilder() { m_house = new House; } virtual void buildWall() { m_house-&gt;setWall(\" villa wall\"); } virtual void buildDoor() { m_house-&gt;setDoor(\"villa door\"); } virtual void buildWindow() { m_house-&gt;setWindow(\"villa window\"); } virtual House* getHouse() { return m_house; }private: House *m_house;};//设计师(指挥者) 负责建造逻辑 //建筑队 干具体的活class Director {public: Director( Builder * build) { m_build = build; } void Construct() { m_build-&gt;buildWall(); m_build-&gt;buildWindow(); m_build-&gt;buildDoor(); }private: Builder * m_build;};void main(){ House *house = NULL; Builder *builder = NULL; Director *director = NULL; // 请一个建造别墅的工程队 builder = new VillaBuilder; //设计师 指挥 工程队 干活 director = new Director(builder); director-&gt;Construct(); house = builder-&gt;getHouse(); house-&gt;getWindow(); house-&gt;getDoor(); delete house; delete builder; //请 FlatBuilder 公寓 builder = new FlatBuilder; director = new Director(builder); director-&gt;Construct(); house = builder-&gt;getHouse(); house-&gt;getWindow(); house-&gt;getDoor(); delete house; delete builder; delete director;} python代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# -*- coding: utf-8 -*-#################################################################### 设计模式专题# # 建造者模式# # Author : zzl# # 编程环境: window10 python2.7# # Date : 20180914##################################################################class House(object): def __init__(self): self.door = \"\" self.wall = \"\" self.window = \"\" def show_door(self): print(self.door) def show_wall(self): print(self.wall) def show_window(self): print(self.window)class Builder(object): def __init__(self): self.house = None def build_wall(self): pass def build_door(self): pass def build_window(self): pass def get_house(self): return self.house# 公寓工程队class FlatBuilder(Builder): def __init__(self): self.house = House() def build_wall(self): self.house.wall = \"flat wall\" def build_door(self): self.house.door = \"flat door\" def build_window(self): self.house.window = \"flat window\" def get_house(self): return self.house# 别墅villa工程队class VillaBuilder(Builder): def __init__(self): self.house = House() def build_wall(self): self.house.wall = \"villa wall\" def build_door(self): self.house.door = \"villa door\" def build_window(self): self.house.window = \"villa window\" def get_house(self): return self.house# 设计师(指挥者)负责建造逻辑# 建筑队干具体的活class Director(object): def __init__(self, builder): self.builder = builder def construct(self): self.builder.build_wall() self.builder.build_door() self.builder.build_window()if __name__ == \"__main__\": # 请一个建造别墅的工程队 builder = VillaBuilder() # 设计师指挥工程队干活 director = Director(builder) director.construct() house = builder.get_house() house.show_door() house.show_wall() house.show_window() # 请公寓FlatBuilder builder = FlatBuilder() director = Director(builder) director.construct() house = builder.get_house() house.show_door() house.show_wall() house.show_window() 源码链接设计模式（四）建造者模式示例代码(python–c++)","link":"/2018/12/04/23种设计模式之（四）建造者模式（python_c++实现）/"},{"title":"设计模式简介","text":"本文主要介给设计模式的基本概念： 设计模式的概念 设计模式的基本原则 设计模式的分类 源码链接 设计模式的概念设计模式是在一定环境中解决某一问题的方案，包括三个基本元素：问题，解决方案和环境，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代 码可靠性，使代码编制真正工程化。​ 设计模式的基本原则 开放封闭原则类的改动是通过增加代码进行的，而不是修改源代码。 单一职责原则类的职责要单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。 依赖倒置原则依赖于抽象(接口),不要依赖具体的实现(类)，也就是针对接口编程。 接口隔离原则不应该强迫客户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。 里氏替换原则任何抽象类出现的地方都可以用他的实现类进行替换。实际就是虚拟机制，语言级别实现面向对象功能。 优先使用组合而不是继承原则如果使用继承，会导致父类的任何变换都可能影响到子类的行为，如果使用对象组合，就降低了这种依赖关系。因此设计过程中应该优先使用组合而不是继承。 迪米特法则一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。设计模式的分类 创建型模式 工厂方法模式（Factory Method Pattern）工厂方法模式用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。 23种设计模式之工厂方法模式 抽象工厂模式（Abstract Factory Pattern）抽象工厂模式的意图是提供一个创建一系列相关或者相互依赖的接口，而无需指定它们具体的类。 23种设计模式之抽象工厂模式 建造者模式（Builder Pattern）建造者模式的意图是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 23种设计模式之建造者模式 原型模式（Prototype Pattern）原型模式是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 23种设计模式原型模式 单例模式（Singleton Pattern）单例模式是保证一个类仅有一个实例，并提供一个访问它的全局访问点。 23种设计模式之单例模式 结构型模式 代理模式（Proxy Pattern）就是为其他对象提供一种代理以控制对这个对象的访问。 23种设计模式之代理模式 装饰者模式（Decorator Pattern）动态的给一个对象添加一些额外的职责。就增加功能来说，此模式比生成子类更为灵活。 23种设计模式之装饰者模式 适配器模式（Adapter Pattern）是将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 23种设计模式之适配器模式 桥接模式（Bridge Pattern）是将抽象部分与实际部分分离，使它们都可以独立的变化。 23种设计模式之桥接模式 组合模式（Composite Pattern）是将对象组合成树形结构以表示“部分–整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。 23种设计模式之组合模式 外观模式（Facade Pattern）是为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 23种设计模式之外观模式 享元模式（Flyweight Pattern）是以共享的方式高效的支持大量的细粒度的对象。 23种设计模式之享元模式 行为型模式 模板方法模式（Template Method Pattern） 模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 23种设计模式之模板方法模式 命令模式（Command Pattern） 命令模式是将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 23种设计模式之命令模式 责任链模式（Chain of Responsibility Pattern） 责任链模式在该模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。 23种设计模式责任链模式 策略模式（Strategy Pattern） 策略模式就是准备一组算法，并将每一个算法封装起来，使得它们可以互换。 23种设计模式之策略模式 中介者模式（Mediator Pattern） 中介者模式就是定义一个中介对象来封装系列对象之间的交互。终结者使各个对象不需要显示的相互调用 ，从而使其耦合性松散，而且可以独立的改变他们之间的交互。 23种设计模式之中介者模式 观察者模式（Observer Pattern） 观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 23种设计模式之观察者模式 备忘录模式（Memento Pattern） 备忘录模式是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 23种设计模式之备忘录模式 访问者模式（Visitor Pattern） 访问者模式就是表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 23种设计模式之访问者模式 状态模式（State Pattern） 状态模式就是对象的行为，依赖于它所处的状态。 23种设计模式之状态模式 解释器模式（Interpreter Pattern）解释器模式就是描述了如何为简单的语言定义一个语法，如何在该语言中表示一个句子，以及如何解释这些句子。 23种设计模式之解释器模式 迭代器模式（Iterator Pattern） 迭代器模式是提供了一种方法顺序来访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 23种设计模式之迭代器模式 源码链接23种设计模式源码（全）链接","link":"/2018/12/04/设计模式简介/"}],"tags":[],"categories":[]}