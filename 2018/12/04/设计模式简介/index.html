<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="23种设计模式概要本文主要介给设计模式的基本概念：  设计模式的概念 设计模式的基本原则 设计模式的分类 源码链接   设计模式的概念设计模式是在一定环境中解决某一问题的方案，包括三个基本元素：问题，解决方案和环境，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代 码可靠性，使代码编制真正工程化。​     设计模式的">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2018/12/04/设计模式简介/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="23种设计模式概要本文主要介给设计模式的基本概念：  设计模式的概念 设计模式的基本原则 设计模式的分类 源码链接   设计模式的概念设计模式是在一定环境中解决某一问题的方案，包括三个基本元素：问题，解决方案和环境，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代 码可靠性，使代码编制真正工程化。​     设计模式的">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-09-19T07:02:18.517Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="23种设计模式概要本文主要介给设计模式的基本概念：  设计模式的概念 设计模式的基本原则 设计模式的分类 源码链接   设计模式的概念设计模式是在一定环境中解决某一问题的方案，包括三个基本元素：问题，解决方案和环境，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代 码可靠性，使代码编制真正工程化。​     设计模式的">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-设计模式简介" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/设计模式简介/" class="article-date">
  <time datetime="2018-12-04T12:07:40.872Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="23种设计模式概要"><a href="#23种设计模式概要" class="headerlink" title="23种设计模式概要"></a><strong>23种设计模式概要</strong></h1><p>本文主要介给设计模式的基本概念：</p>
<ul>
<li><strong>设计模式的概念</strong></li>
<li><strong>设计模式的基本原则</strong></li>
<li><strong>设计模式的分类</strong></li>
<li><strong>源码链接</strong></li>
</ul>
<hr>
<h2 id="设计模式的概念"><a href="#设计模式的概念" class="headerlink" title="设计模式的概念"></a><strong>设计模式的概念</strong></h2><p>设计模式是在一定环境中解决某一问题的方案，包括三个基本元素：问题，解决方案和环境，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代 码可靠性，使代码编制真正工程化。<br>​    </p>
<h2 id="设计模式的基本原则"><a href="#设计模式的基本原则" class="headerlink" title="设计模式的基本原则"></a><strong>设计模式的基本原则</strong></h2><ol>
<li>开放封闭原则<br>类的改动是通过增加代码进行的，而不是修改源代码。</li>
<li>单一职责原则<br>类的职责要单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。</li>
<li>依赖倒置原则<br>依赖于抽象(接口),不要依赖具体的实现(类)，也就是针对接口编程。</li>
<li>接口隔离原则<br>不应该强迫客户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。</li>
<li>里氏替换原则<br>任何抽象类出现的地方都可以用他的实现类进行替换。实际就是虚拟机制，语言级别实现面向对象功能。</li>
<li>优先使用组合而不是继承原则<br>如果使用继承，会导致父类的任何变换都可能影响到子类的行为，如果使用对象组合，就降低了这种依赖关系。因此设计过程中应该优先使用组合而不是继承。</li>
<li>迪米特法则<br>一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。<h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a><strong>设计模式的分类</strong></h2></li>
</ol>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><ol>
<li><p>工厂方法模式（Factory Method Pattern）<br>工厂方法模式用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82685676" target="_blank" rel="noopener">23种设计模式之工厂方法模式</a></p>
</li>
<li><p>抽象工厂模式（Abstract Factory Pattern）<br>抽象工厂模式的意图是提供一个创建一系列相关或者相互依赖的接口，而无需指定它们具体的类。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82697380" target="_blank" rel="noopener">23种设计模式之抽象工厂模式</a></p>
</li>
<li><p>建造者模式（Builder Pattern）<br>建造者模式的意图是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82707149" target="_blank" rel="noopener">23种设计模式之建造者模式</a></p>
</li>
<li><p>原型模式（Prototype Pattern）<br>原型模式是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82710730" target="_blank" rel="noopener">23种设计模式原型模式</a></p>
</li>
<li><p>单例模式（Singleton Pattern）<br>单例模式是保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82685753" target="_blank" rel="noopener">23种设计模式之单例模式</a></p>
</li>
</ol>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><ol start="6">
<li><p>代理模式（Proxy Pattern）就是为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82712547" target="_blank" rel="noopener">23种设计模式之代理模式</a></p>
</li>
<li><p>装饰者模式（Decorator Pattern）动态的给一个对象添加一些额外的职责。就增加功能来说，此模式比生成子类更为灵活。 </p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82715352" target="_blank" rel="noopener">23种设计模式之装饰者模式</a></p>
</li>
<li><p>适配器模式（Adapter Pattern）是将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 </p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82718528" target="_blank" rel="noopener">23种设计模式之适配器模式</a></p>
</li>
<li><p>桥接模式（Bridge Pattern）是将抽象部分与实际部分分离，使它们都可以独立的变化。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82721061" target="_blank" rel="noopener">23种设计模式之桥接模式</a></p>
</li>
<li><p>组合模式（Composite Pattern）是将对象组合成树形结构以表示“部分–整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82720531" target="_blank" rel="noopener">23种设计模式之组合模式</a></p>
</li>
<li><p>外观模式（Facade Pattern）是为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82721835" target="_blank" rel="noopener">23种设计模式之外观模式</a></p>
</li>
<li><p>享元模式（Flyweight Pattern）是以共享的方式高效的支持大量的细粒度的对象。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82723788" target="_blank" rel="noopener">23种设计模式之享元模式</a></p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2></li>
<li><p>模板方法模式（Template Method Pattern）<br> 模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82728271" target="_blank" rel="noopener">23种设计模式之模板方法模式</a></p>
</li>
<li><p>命令模式（Command Pattern）<br> 命令模式是将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82732266" target="_blank" rel="noopener">23种设计模式之命令模式</a></p>
</li>
<li><p>责任链模式（Chain of Responsibility Pattern）<br> 责任链模式在该模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。 </p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82751779" target="_blank" rel="noopener">23种设计模式责任链模式</a></p>
</li>
<li><p>策略模式（Strategy Pattern）<br> 策略模式就是准备一组算法，并将每一个算法封装起来，使得它们可以互换。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82757428" target="_blank" rel="noopener">23种设计模式之策略模式</a></p>
</li>
<li><p>中介者模式（Mediator Pattern）<br> 中介者模式就是定义一个中介对象来封装系列对象之间的交互。终结者使各个对象不需要显示的相互调用 ，从而使其耦合性松散，而且可以独立的改变他们之间的交互。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82762727" target="_blank" rel="noopener">23种设计模式之中介者模式</a></p>
</li>
<li><p>观察者模式（Observer Pattern）<br> 观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82762865" target="_blank" rel="noopener">23种设计模式之观察者模式</a></p>
</li>
<li><p>备忘录模式（Memento Pattern）<br> 备忘录模式是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82763043" target="_blank" rel="noopener">23种设计模式之备忘录模式</a></p>
</li>
<li><p>访问者模式（Visitor Pattern）<br> 访问者模式就是表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82763191" target="_blank" rel="noopener">23种设计模式之访问者模式</a></p>
</li>
<li><p>状态模式（State Pattern）<br> 状态模式就是对象的行为，依赖于它所处的状态。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82763288" target="_blank" rel="noopener">23种设计模式之状态模式</a></p>
</li>
<li><p>解释器模式（Interpreter Pattern）<br>解释器模式就是描述了如何为简单的语言定义一个语法，如何在该语言中表示一个句子，以及如何解释这些句子。 </p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82763397" target="_blank" rel="noopener">23种设计模式之解释器模式</a></p>
</li>
<li><p>迭代器模式（Iterator Pattern）<br> 迭代器模式是提供了一种方法顺序来访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
<p><a href="https://blog.csdn.net/zzl_python/article/details/82763533" target="_blank" rel="noopener">23种设计模式之迭代器模式</a></p>
</li>
</ol>
<h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a><strong>源码链接</strong></h2><p><a href="https://download.csdn.net/download/zzl_python/10674882" target="_blank" rel="noopener">23种设计模式源码（全）链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/04/设计模式简介/" data-id="cjp9prru8000okowawcnl9yhk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/12/04/23种设计模式之（一）单例模式（python_c++实现)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2018/12/04/23种设计模式之（八）适配器模式（python_c++实现）/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/04/23种设计模式之（一）单例模式（python_c++实现)/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/12/04/设计模式简介/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/12/04/23种设计模式之（八）适配器模式（python_c++实现）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/12/04/23种设计模式之（二）工厂方法模式（python_c++实现）/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/12/04/23种设计模式之（二十）访问者模式（python_c++实现)/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>